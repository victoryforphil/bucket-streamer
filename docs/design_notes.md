# High Level Goals
- Given a s3 hosted H265 video file - respond to requests for invidual frames when given a specifc irap and frame byte offsets.
- Realtime performance (20FPS minimum)
- Scalable across kubernetes clusters
- Web client renderer

# Design Ideas
- Use a WebSocket connection to maitain session support and routing 
    - Offers live back-and-forth channel 
    - Client can send requests for given frames
    - Server can store reqeusts in LIFO queues to respond the clients latest request
    - As frames process - can send them out on WebSockets
    - If seperate from processing, one processing loop can respond to multiple clients.
- Main processing loop (conceptual):
    - LOAD_HEADER: Load File Header from S3 for `src_video`
    - LOAD_FRAME: Load frame data from S3 for `src_video`
    - DECODE_FRAME: Decode the frame requested 
    - ENCODE_FRAME: Encode the frame as the response time (E.g. JPEG)
- FFMpeg Session Note:
    - FFMpeg decoder creation takes time (~33ms) and was a bottle neck on the last design 
    - In theory if the clips are the same "specs" (resolution, format, colorspace, etc) then a single one can be re-used.
    - In reality we can more easily create a decoder per video clip.
- Loading when we need it:
    - `src_video` 
        - We know this early on - before even we start requesting frames. 
        - Can easily start to read from this "ahead of time" or do common tasks
        - can be used as a session creation (or higher level sessions discussed later)
    - Headers:
        - We can load these once we know `src_video` 
        - Saves a good 10-20ms
    - Frames: 
        - We at minimum have to respond to requested frames as we get them
        - However pre-loading or at least caching at a common layer could help.
- Pipeline approach
    - Ideally we can use a "streaming" / "pipeline" approach to this application
    - A core set of tasks (async) respond to a bus of events. 
    - We process data in a streaming / chunked fashion to get data back to the client ASAP
        - We can for example load sections of the s3 video file between IRAP frames 
            - _Should the clients send all the iraps ahead of time so we know the chunks?_
        - On each valid `video_chunk` (IRAP + its "delta" frames), we can decode into JPEG
        - We can emit a `FRAME_DONE` event that can be stored / cached and emitted to any "interested" parties
            - Interested Parties: Clients that have requested said frame. Pub/Sub pattern
        - If we are fancy we can respond in HTTP streamign
    - Use websockets for clients to connect to this bus system (or an sub-set of for the client) to operate live
- Client WebSocket flow
    - Clients send the list of clips they are interested in
    - Clients can send a "Register Chunk(s)" message to preload / register irap sections
    - Clients can then start to "Request Chunk" or "Request Frames" 
        - Chunk by irap and will send all the frames in said chunk
        - Frams uses Irap + byte offset and will said just the requested frames
    - Stream server will start the pipeline and convert frames - noting that WS session's "Interested frames"
    - Stream server sends frames to the session as they are converted.
        - In the future we should check a cache first (spread this as wide as possible)

# Kubernetes / Cluster Supper
- Will need to run in a kubernetes cluster 
- This introducing load balancing challenges
- Need a way to test easily locally and simulate
    - minik8s or similar like system in a docker container?
    - nginx routing or similar will be needed.


# Components
- Streaming Server
    - Main binary / single process for the streaming server
    - Operates the websocket server and connection pull
    - Runs in its container by it self in a pod
    - Main unit in caching 
    - Has main async event loop that runs our event queue and tasks
    - Channels:
        - Represents a given video track and related decoder and caches
        - Can be seperated out from websocket to allow different WS sessions to share compute.
- Streaming CLI
    - Mimimal CLI wraper to connect to Streaming server
    - Implements a Web socket client
    - Used to benchmark 
- Repo CLI
    - Helper CLI for common tasks
    - Can add utils like the h265 prep - benchmarking, docker commands etc.
- Mock S3 
    - Something that can be launch in docker / compose / kubernetes
# Technology Selection
- Streaming Server
    - Rust
    - Tokio for the async / threading
    - Axum / Axtix / Tokiop Tungstenite (needs research)
    - invokes ffmpeg (`ffmpeg-sys`) 
- Mock S3 
    - Seaweed FS strong choice
    - MinIo-like but hopefully something better exists
    - WebDashboard included (like minio) strong benefit (for uploading content)
        - If not a big deal, we can add it to our Repo CLI
- Repo CLI
    - Rust + Clap
    - Open to other CLI / TUI frameowrks
    - Ratatui for TUI 
- Streaming CLI
    - Rust + Clap

# Server Layout
- Server Binary
    - Web Socket Server
        - Websocket Connection->Session
    - Channels (per clip)
        - Decoder
        - VideoHeader?
        - Clips
            - status
                - REGISTERED
                - DECODED
            - irap_byte
            - frames
                - byte_offset
                - frame_index
                - timestamps?
                - jpeg_data
    - Pipeline (tasks)
        - WS Listener
            - Connected to the Websocket server / sessions
            - Listens for events from client and shares with pipeline
            - WS//REGISTER_CHANNEL -> INT//SPAWN_CHANNEL
                - Sent per video clip that we discover and want to most likely start processing on 
            - WS//REGISTER_CLIP -> INT//SPAWN_CLIP + INT//DECODE_CLIP
                - Send per IRAP segment found
                - Causes a clip spawn via the Clip spawner
                - Will also invoke a render clip call if 
            - WS//REQUEST_FRAME
                - Sent anytime the client wishes to get some frames back
                - LIFO queue - respond to latest request first ideally.
                - 
        - Channel Spawner
        - Clip Spawner
        - Clip Decoder
        - Clip Encoder
        - WS Sender